## cached plan must not change result type 原因和解法  
                                                                                                  
### 作者                                                                                                  
digoal                                                                                                  
                                                                                                  
### 日期                                                                                                  
2019-04-17                                                                                                  
                                                                                                  
### 标签                                                                                                  
PostgreSQL , cached plan must not change result type , prepared statement , 绑定变量       
                 
----                                                                                            
                                                                                              
## 背景      
PostgreSQL的优化器是非常复杂的，和Oracle属于一个量级，所以如果是OLTP系统，建议使用绑定变量，减少sql parser, plan的开销。  
  
在使用绑定变量时，可能会遇到这样的问题，当结构发生变化时，如果绑定变量的SQL结果依赖这个结构，那么会报类似错误：  
  
```  
ERROR:  0A000: cached plan must not change result type  
LOCATION:  RevalidateCachedQuery, plancache.c:745  
```  
  
原因是绑定变量对应SQL的结果与当前结构下对应的结果不一致。  
  
例子：  
  
```  
postgres=# create table tc (id int ,c1 int);  
CREATE TABLE  
postgres=# insert into tc values (1,1);  
postgres=# prepare x (int) as select * from tc where id=$1;  
PREPARE  
postgres=# \set VERBOSITY verbose  
postgres=# execute x(1);  
 id | c1   
----+----  
  1 |  1  
(1 row)  
  
postgres=# alter table tc add column c2 int;  
ALTER TABLE  
postgres=# execute x(1);  
ERROR:  0A000: cached plan must not change result type  
LOCATION:  RevalidateCachedQuery, plancache.c:745  
```  
  
## 解法  
discard all后，重新绑定即可。  
  
```  
postgres=# discard all;  
DISCARD ALL  
postgres=# execute x(1);  
ERROR:  26000: prepared statement "x" does not exist  
LOCATION:  FetchPreparedStatement, prepare.c:535  
  
  
postgres=# prepare x (int) as select * from tc where id=$1;  
PREPARE  
postgres=# execute x(1);  
 id | c1 | c2   
----+----+----  
  1 |  1 |     
(1 row)  
```  
    
## 参考  
https://www.postgresql.org/docs/11/sql-prepare.html  
  
https://www.postgresql.org/docs/11/libpq-async.html  
  
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
#### [免费领取阿里云RDS PostgreSQL实例、ECS虚拟机](https://www.aliyun.com/database/postgresqlactivity "57258f76c37864c6e6d23383d05714ea")
  
  
#### [大量阿里云PG解决方案: 任意维度实时圈人; 时序数据实时处理; 时间、空间、业务 多维数据实时透视; 独立事件相关性分析; 海量关系实时图式搜索; 社交业务案例; 流式数据实时处理案例; 物联网; 全文检索; 模糊、正则查询案例; 图像识别; 向量相似检索; 数据清洗、采样、脱敏、批处理、合并; GIS 地理信息空间数据应用; 金融业务; 异步消息应用案例; 海量数据 冷热分离; 倒排索引案例; 海量数据OLAP处理应用;](https://yq.aliyun.com/topic/118 "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥的 / digoal's PostgreSQL文章入口 - 努力做成PG资源最丰富的个人blog](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
![德哥的微信 / digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
